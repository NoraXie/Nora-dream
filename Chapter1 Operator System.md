### 参考资料

> 参考书

操作系统概念  
深入理解计算机系统  
操作系统: 精髓与设计

> 参考视频

清华大学学堂在线公开课: &lt;&lt;操作系统&gt;&gt;  
清华大学学堂在线操作系统实验课: &lt;&lt;操作系统uCore实验&gt;&gt;


### 磁盘管理

U盘,光盘,软盘,机械式硬盘,固态硬盘,磁带.

> 机械硬盘

![机械硬盘](/assets/磁盘结构1.png)  
![机械硬盘](/assets/磁盘结构2.jpg)

真空: 转速太快,与其它物体碰撞后果严重.用于	防尘.  
钢性盘片: 双面可读写  
机械臂: 可移动    
磁头: 读取电气信号  
磁道Tracks: 同心圆,不同的磁道周长不同,周长越长可以存储的数据越多.  
扇区Sector: 共512Bytes.数据按扇区来管理数据.包括扇区号,磁道号,盘片号等等.这些属于额外开销.  
柱面Cylinder: 所有盘片上同一磁道的构成.  
分区Partition: 磁盘的逻辑边界.不分分区,只能有一个文件系统.   
低级格式化: 磁盘出厂时进行格式化,主要是为了划分磁道,扇区等.但不进行分区.

> 指标

平均寻道时间(Average Seek Time): 指磁头移动到数据所在磁道需要的时间，这是衡量硬盘机械性能的重要指标,越短越好
平均潜伏期(Average Latency): 指当磁头移动到数据所在的磁道以后，等待指定的数据扇区转动到磁头下方的时间
平均访问时间(Average Access Time): 指从读/写指令写出到第一笔数据读/写实际开始所用的平均时间
数据传输率:(Data Transfer Rate): 指硬盘读/写数据的速度,单位为兆字节每秒(MB/s)
转速: 5400rpm/7200rpm/15000rpm, 越大越好  
外道: 比内道读写速率快,因为同样的时间段,磁头扫过的长度外道比内道长.

> 硬盘缓存区

硬盘缓存区也称缓存,作用是平衡内部与外部的数据传输率.为了减少洗衣机的等待时间,硬盘会将读取的资料先存入缓冲区,等全部读完或缓冲区填满后再以接口速率快速向主机发送


> MBR

Master boot record: 主引导记录.

O磁道0扇区共512Bytes,叫主引导记录.不属于操作系统的独立的存储空间,被分成三段.

**0-445Bytes**: boot loader程序,引导磁盘上的操作系统,使之运行起来.

**446-509Bytes**: 每16Bytes构成一个分区,共64Bytes, 因此最多可以有4个分区.

**510-511Bytes**: 一个字节存一个magic number,标识MBR是否有效, 这两个字节的16进制数为: 5A.


> 分区

文件存储在磁盘上以柱面为基准,即一个文件放在了同一柱面所有盘面上.因此为了方便文件的存储,将磁盘按柱面进行分区.由MBR可知一个磁盘最多只有四个分区.

- 最多四个主分区
- 3个主分区+1个扩展分区
- 1个扩展分区可以指向多个逻辑分区

问题是,文件具体放在一个分区的什么位置,这个文件有多大,是什么类型的文件?...

这些内容必须有效的管理起来.于是有了一个软件叫**文件系统**.文件系统在管理分区时,将物理分区分成**元数据存储区**和**数据存储区**两个逻辑空间来管理.数据存储区里的最小存储单元是block.元数据区有一个区域---块位图(bitmap): 将所有数据存储区里的所有block在这里建立相应的位.0表示unused,1表示used. 元数据区还有一个区域---文件路径管理区.

于是一个文件在文件系统中是这样的组成: 
一份元数据: 文件名称,文件路径, block的编号,文件有多少个block等.
一份数据: 一个文件的所有block.

哪些block是空闲的,哪些block已经被占用?
每个block的第一位进行标记,为1表示空闲,0表示被占用.但是这样做效率非常低!所以实际在管理block时,在元数据区找一块空间来管理block的占用状态.

> 文件系统初实

- 元数据
	- 块位图: 提高查找空闲block的速度.
	- inode: 一个文件一个inode. inode号,文件属主,属主,blocks. 没有文件名.
	- inode位图: 用来遍历inode条目是否空闲,可提高遍历速度.
- 数据
	- blocks

**NOTE:**目录也是一个文件.所以文件名其实涉及多个文件,如:/etc/passwd,这其中有

- / --- 根inode号,根block中保存有 etc及其inode号
- etc --- etc inode, etc block中保存有 passwd 及其 inode号
- pawwd --- passwd inode号, passwd blocks 

每次如此找文件,有些费力.实际是在第一次遍历结束后建立了一个缓存条目: dentry.第一个dentry都记录了/etc/passwd这种目录对应的所有block.

**创建文件**

/data/test.txt 10k数据 每一个block 2k

- Step1扫描inode位图,找一个空闲的inode,比如inode号为 100
- Step2找到data对应的inode,inode号为99,由inode找到对应的block,block号为11
- Step3在这个11号block号中添加一条数据inode_id:100,name: test.txt
- Step4扫描block位图,找到空闲块后,往block里写数据,并将这个block号保存在100号inode中.

**删除文件**

只需要将文件对应的inode位图与block位图标记为未使用,下次再写数据时,只是覆盖了原来block里的内容.



ls -l中列出的文件次数,表示的硬链接的次数.如果一个文件的硬链接的次数大于2时,这个文件不会真正被删除.

**复制文件**

实际就是一个创建新文件.但是同一个分区剪切,并没有创建新文件,而只是修改了目录文件block里的文件名而已,inode与block的编号都没有变化,因此同一个分区上的文件剪切速度很快.

**创建链接**

/backup/a/m.txt
/backup/b/n.txt
这两个文件可以指向同一个inode.这就是硬链接.

软链接的inode中没有block,但是它存的是一个文件路径.要找这个软链接指向的真实的文件,得按这个路径再去找一个.软链接的权限都是777,因为这个软链接最终指向的文件有自己的权限,用户的访问权限由真实文件的权限决定.

```ZSH
// 格式 ln [-s -v] src dest, 不带选项是硬链接 -s软链接 -v verbose
// 硬链接 
mkdir /backup
cd /backup
cp /etc/rc.d/rc.sysinit ./abc
ls -l
mkdir test
ln abc test/abc2
ls -l
cd test
ls -l
man ls 
cd ..
ls -i
ls -i test/
rm abc
ls -li test/

//软链接 
mv test/abc2 abc
ln -sv /backup/abc /backup/test/abc2
ls -i
ls -li test
```

**硬链接**

- 只能对文件创建,不能对目录创建硬链接. 目录硬链接的次数始终是2.
- 硬链接指向inode
- 不能跨文件系统创建
- 创建硬链接会增加文件被链接的次数

**软链接** 

- 文件和目录都可以创建
- 指向的是一个路径
- 可以跨文件系统
- 不会增加文件被链接的次数
- 其大小为其所指向路径的字符数长度

```ZSH
// du 命令: estimate file space usage
du -sh [目录]
// df 命令: report file system disk space usage
df 
df -h
df -i
df -i -P
```

> 设备文件

Linux的思想之一是**一切皆文件**,所以设备在Linux里也是文件,叫设备文件,都在/dev目录下./dev下的所有文件都有一个设备号(major number)和次设备号(minor number).主设备号用于标识设备类型,次设备号用于标识同一种类型的多个不同设备.设备文件并不真正占用block,只在inode里存储着设备文件主次设备号,所以这类文件没有大小.

设备文件主要目的是设备的访问入口,默认是被内核使用的.每一个设备文件是通过内核与一个实际的物理设备连接起来的.

**块设备b**: 按块为单位,随机访问的设备.常见: 硬盘

**字符设备c**: 按字符为单位,线性访问的设备.常见: 键盘

设备文件的创建: `mknod命令 make block or character special files`

```ZSH
// mknod [OPTION]... NAME TYPE [MAJOR MINOR]
// 创建一个b设备,设备名为mydev, 主设备号66, 次设备号0
mknod mydev c 66 0
// 创建一个b设备,设备名为mydev, 主设备号66, 次设备号1, 设备权限为640
mknod -m 640 mydev2 c 66 1
```

> 硬盘设备

设备文件名

IDE,ATA: 以hd开头(centos6以后也用sd开头)
SATA: 以sd开头
SCSI: 以sd开头
USB: 以sd开头

举栗: 一个处理器可以接一块硬盘,所以双核的处理器可以接四块硬盘.四个硬盘在文件系统中这么定义

- 第一块硬盘: /dev/sda
	- 分区1: /dev/sda1
	- 分区2: /dev/sda2
	- 分区3: /dev/sda3
	- 分区4: /dev/sda4
	- 逻辑分区5: /dev/sda5
	- 依此类推
- 第二块硬盘: /dev/sdb
- 第三块硬盘: /dev/sdc
- 第四块硬盘: /dev/sdd

查看系统上的所有磁盘信息`fdisk`	

#### 文件系统

文件系统是属于内核.文件系统需要借助用户空间的进程,然后通过系统调用进入内核空间.

**文件系统分类**

- VFS: 虚拟文件系统,支持众多类型的文件系统
- CIFS: Windows 上的网卡邻居用的文件系统
- FAT16/FAT32/NTFS: Windows
- ISO9660: 光盘
- ext2,ext3,ext4,xfs,reiserfs:
- jfs: IBM的日志文件系统
- NFS: 网络文件系统
- gfs2: 全局文件系统
- ocfs2: 集群文件系统

Linux几乎支持上述所有文件系统,因为有VFS用来管理所有文件系统.但是Linux对NTFS的支持不是很好,最好是不要往NTFS的文件系统里写数据.有了VFS后,用户空间进程只需要通过一个系统调用与VFS交互即可.

每一个分区可以是不同的文件系统,但是最后都要挂载到根目录下.

内核只知道根的位置.


**磁盘格式化**

- 低级格式化: 厂商完成,负责创建磁道,扇区
- 高级格式化: 创建文件系统,这后才可被挂载.

**创建分区(创建文件系统)**

可以用`fdisk /dev/sda `

>fdisk /dev/sda
>> p: 显示当前硬件的分区,包括没保存的改动  
>> n: 创建新分区  
>>> e: 扩展分区
>>> p: 主分区(1-4)
>> d: 删除一个分区  
>> w: 保存退出  
>> t: 修改分区类型  
>> l: 显示所支持的所有类型  







